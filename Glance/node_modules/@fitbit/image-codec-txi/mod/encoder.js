var _a, _b;
import BufferCursor from './BufferCursor';
import { TXIOutputFormat } from './types';
import RunLengthEncoder from './RunLengthEncoder';
var TextureFormat;
(function (TextureFormat) {
    TextureFormat[TextureFormat["A8"] = 524296] = "A8";
    TextureFormat[TextureFormat["BGR565"] = 17827173] = "BGR565";
    TextureFormat[TextureFormat["BGRA8888"] = 18909320] = "BGRA8888";
    TextureFormat[TextureFormat["ABGR6666"] = 35153510] = "ABGR6666";
    TextureFormat[TextureFormat["ABGR8888"] = 35686536] = "ABGR8888";
})(TextureFormat || (TextureFormat = {}));
var TXI_FILE_TYPE = 0x0A697874;
var TXI_FILE_VERSION = 0x20000028;
var TXI_HEADER_LENGTH = 40;
var INPUT_FORMAT_BPP = 4;
function rescaleColor(value, newMax) {
    return ((value * newMax + 127) / 255) | 0;
}
// BPP = bytes per pixel
var textureBPP = (_a = {},
    _a[TextureFormat.A8] = 1,
    _a[TextureFormat.BGRA8888] = 4,
    _a[TextureFormat.ABGR8888] = 4,
    _a[TextureFormat.BGR565] = 2,
    _a[TextureFormat.ABGR6666] = 3,
    _a);
var pixelEncoders = (_b = {},
    _b[TextureFormat.A8] = function (data, offset, output) {
        output[0] = data[offset];
    },
    _b[TextureFormat.BGRA8888] = function (data, offset, output) {
        output[0] = data[offset + 2];
        output[1] = data[offset + 1];
        output[2] = data[offset];
        output[3] = data[offset + 3];
    },
    _b[TextureFormat.ABGR8888] = function (data, offset, output) {
        output[0] = data[offset + 3];
        output[1] = data[offset + 2];
        output[2] = data[offset + 1];
        output[3] = data[offset];
    },
    _b[TextureFormat.BGR565] = function (data, offset, output) {
        var r5 = rescaleColor(data[offset], 31);
        var g6 = rescaleColor(data[offset + 1], 63);
        var b5 = rescaleColor(data[offset + 2], 31);
        output[0] = 0xFF & ((g6 << 5) | b5); // gggbbbbb
        output[1] = 0xFF & ((g6 >> 3) | (r5 << 3)); // rrrrrggg
    },
    _b[TextureFormat.ABGR6666] = function (data, offset, output) {
        if (data[offset + 3] === 0) {
            output[0] = 0;
            output[1] = 0;
            output[2] = 0;
            return;
        }
        var r = rescaleColor(data[offset], 63);
        var g = rescaleColor(data[offset + 1], 63);
        var b = rescaleColor(data[offset + 2], 63);
        var a = rescaleColor(data[offset + 3], 63);
        output[0] = 0xFF & ((b << 6) | a); // bbaaaaaa
        output[1] = 0xFF & ((g << 4) | (b >> 2)); // ggggbbbb
        output[2] = 0xFF & ((r << 2) | (g >> 4)); // rrrrrrgg
    },
    _b);
function findTextureFormat(outputFormat, rle) {
    if (outputFormat === TXIOutputFormat.RGBA8888) {
        return rle ? TextureFormat.ABGR8888 : TextureFormat.BGRA8888;
    }
    switch (outputFormat) {
        case TXIOutputFormat.A8: return TextureFormat.A8;
        case TXIOutputFormat.RGB565: return TextureFormat.BGR565;
        case TXIOutputFormat.RGBA6666: return TextureFormat.ABGR6666;
    }
    throw new Error("No known texture format for TXI output format " + outputFormat);
}
function maxOutputSize(image, outputFormat, withRLE) {
    var width = image.width, height = image.height;
    var bpp = textureBPP[findTextureFormat(outputFormat, withRLE)];
    // RLE has no padding or duplicated rows, but in the worst case where nothing
    // can be compressed incurs a 1-byte per pixel overhead
    var maxBytesWithRLE = width * height * (bpp + 1);
    // Without RLE, the worst case is more complex:
    // - The final row is duplicated, so height + 1.
    // - For each row, the final pixel is duplicated, so width + 1.
    // - Each row is padded up to a 32-bit boundary, so add a possible
    // 3 bytes for each row we write.
    var maxBytesWithoutRLE = ((width + 1) * (height + 1) * bpp) + ((height + 1) * 3);
    return (withRLE ? maxBytesWithRLE : maxBytesWithoutRLE) + TXI_HEADER_LENGTH;
}
function encodeWithFixedRLE(image, options) {
    var textureFormat = findTextureFormat(options.outputFormat, options.rle);
    var bpp = textureBPP[textureFormat];
    var encoder = pixelEncoders[textureFormat];
    var imageData = new Uint8Array(image.data.buffer);
    var width = image.width, height = image.height;
    var cursor = new BufferCursor(maxOutputSize(image, options.outputFormat, options.rle));
    cursor.seek(TXI_HEADER_LENGTH);
    var rle = options.rle ? new RunLengthEncoder(cursor, bpp) : undefined;
    var outputPixel = new Uint8Array(bpp);
    var emit;
    if (rle) {
        emit = function () { return rle.encode(outputPixel); };
    }
    else {
        emit = function () { return cursor.writeArray(outputPixel); };
    }
    function writeRow(y) {
        var offset = width * y;
        for (var x = 0; x < width; x += 1) {
            var idx = (offset + x) * INPUT_FORMAT_BPP;
            encoder(imageData, idx, outputPixel);
            emit();
        }
        if (!rle) {
            emit();
            cursor.seek((cursor.tell() + 3) & ~3);
        }
    }
    function writeBody() {
        for (var y = 0; y < height; y += 1)
            writeRow(y);
        if (rle) {
            rle.flush();
        }
        else {
            writeRow(height - 1);
        }
    }
    function writeHeader() {
        var formatType = textureFormat;
        if (rle)
            formatType |= 268435456 /* RLE */;
        var imageDataLen = cursor.tell() - TXI_HEADER_LENGTH;
        var dv = new DataView(cursor.buffer);
        [
            TXI_FILE_TYPE,
            TXI_FILE_VERSION,
            imageDataLen,
            0,
            formatType,
            rle ? 0 : 1,
            width,
            height,
            imageDataLen,
            0xDEADBEEF,
        ].forEach(function (val, index) { return dv.setUint32(index * 4, val, true); });
    }
    writeBody();
    writeHeader();
    return cursor.slice();
}
export function encode(image, options) {
    var outputFormat = options.outputFormat || TXIOutputFormat.RGBA8888;
    if (options.rle !== 'auto') {
        return encodeWithFixedRLE(image, { outputFormat: outputFormat, rle: !!options.rle });
    }
    var withRLE = encodeWithFixedRLE(image, { outputFormat: outputFormat, rle: true });
    var sizeWithoutRLE = maxOutputSize(image, outputFormat, false);
    if (withRLE.byteLength <= sizeWithoutRLE)
        return withRLE;
    return encodeWithFixedRLE(image, { outputFormat: outputFormat, rle: false });
}
//# sourceMappingURL=encoder.js.map