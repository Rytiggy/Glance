var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import * as stream from 'stream';
import ErrorSubclass from 'error-subclass';
import * as jrpc from './protocol';
export var ErrorCodes;
(function (ErrorCodes) {
    ErrorCodes[ErrorCodes["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
    ErrorCodes[ErrorCodes["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
    ErrorCodes[ErrorCodes["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
    ErrorCodes[ErrorCodes["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
    ErrorCodes[ErrorCodes["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
})(ErrorCodes || (ErrorCodes = {}));
var RPCError = (function (_super) {
    __extends(RPCError, _super);
    function RPCError(message, code, data) {
        if (code === void 0) { code = ErrorCodes.INTERNAL_ERROR; }
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.data = data;
        return _this;
    }
    RPCError.prototype.toErrorObject = function () {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    };
    RPCError.displayName = 'RPCError';
    return RPCError;
}(ErrorSubclass));
export { RPCError };
var InvalidRequest = (function (_super) {
    __extends(InvalidRequest, _super);
    function InvalidRequest(message, badObject) {
        return _super.call(this, message, ErrorCodes.INVALID_REQUEST, { badObject: badObject }) || this;
    }
    InvalidRequest.displayName = 'InvalidRequest';
    return InvalidRequest;
}(RPCError));
var MethodNotFound = (function (_super) {
    __extends(MethodNotFound, _super);
    function MethodNotFound(message, data) {
        return _super.call(this, message, ErrorCodes.METHOD_NOT_FOUND, data) || this;
    }
    MethodNotFound.displayName = 'MethodNotFound';
    return MethodNotFound;
}(RPCError));
export { MethodNotFound };
var InvalidParams = (function (_super) {
    __extends(InvalidParams, _super);
    function InvalidParams(message, data) {
        return _super.call(this, message, ErrorCodes.INVALID_PARAMS, data) || this;
    }
    InvalidParams.displayName = 'InvalidParams';
    return InvalidParams;
}(RPCError));
export { InvalidParams };
var ParseError = (function (_super) {
    __extends(ParseError, _super);
    function ParseError(message, data) {
        return _super.call(this, message, ErrorCodes.PARSE_ERROR, data) || this;
    }
    ParseError.displayName = 'ParseError';
    return ParseError;
}(RPCError));
export { ParseError };
var MethodCallTimeout = (function (_super) {
    __extends(MethodCallTimeout, _super);
    function MethodCallTimeout(method) {
        var _this = _super.call(this, method + " timed out") || this;
        _this.method = method;
        return _this;
    }
    MethodCallTimeout.displayName = 'MethodCallTimeout';
    return MethodCallTimeout;
}(ErrorSubclass));
export { MethodCallTimeout };
var NumericIdIterator = (function () {
    function NumericIdIterator(initialValue) {
        if (initialValue === void 0) { initialValue = 0; }
        if (initialValue % 1 !== 0 ||
            initialValue > Number.MAX_SAFE_INTEGER ||
            initialValue < Number.MIN_SAFE_INTEGER) {
            throw new TypeError('Initial value must be an integer');
        }
        this.state = initialValue;
    }
    NumericIdIterator.prototype.next = function () {
        var value = this.state;
        if (this.state === Number.MAX_SAFE_INTEGER) {
            this.state = Number.MIN_SAFE_INTEGER;
        }
        else {
            this.state += 1;
        }
        return { value: value, done: false };
    };
    return NumericIdIterator;
}());
export { NumericIdIterator };
var Peer = (function (_super) {
    __extends(Peer, _super);
    function Peer(handlers, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, {
            readableObjectMode: true,
            writableObjectMode: true,
            allowHalfOpen: false,
        }) || this;
        _this.pendingRequests = new Map();
        _this.ended = false;
        _this.onRequest = handlers.onRequest;
        _this.onNotification = handlers.onNotification;
        if (options.idIterator) {
            _this.requestIdIterator = options.idIterator;
        }
        else {
            _this.requestIdIterator = new NumericIdIterator();
        }
        _this.once('finish', function () { return _this.onend(); });
        return _this;
    }
    Peer.prototype.onend = function () {
        this.ended = true;
        this.pendingRequests.forEach(function (_a) {
            var reject = _a.reject;
            reject(new Error('RPC stream closed'));
        });
    };
    Peer.prototype.assertNotEnded = function () {
        if (this.ended)
            throw new Error('RPC stream closed');
    };
    Peer.prototype.callMethod = function (method, params, _a) {
        var _this = this;
        var _b = (_a === void 0 ? {} : _a).timeout, timeout = _b === void 0 ? undefined : _b;
        this.assertNotEnded();
        var idResult = this.requestIdIterator.next();
        if (idResult.done) {
            throw new Error('Out of Request IDs! Request ID iterator is not infinite');
        }
        var id = idResult.value;
        if (this.pendingRequests.has(id)) {
            throw new Error('Request ID iterator yielded a value which was already used in a pending request');
        }
        var timer;
        var promise = new Promise(function (resolve, reject) {
            _this.push(jrpc.request(id, method, params));
            _this.pendingRequests.set(id, { resolve: resolve, reject: reject });
            if (timeout !== undefined) {
                timer = setTimeout(function () { return reject(new MethodCallTimeout(method)); }, timeout);
            }
        });
        if (timer !== undefined) {
            var timerRef_1 = timer;
            return promise.then(function (value) {
                clearTimeout(timerRef_1);
                return value;
            }, function (reason) {
                clearTimeout(timerRef_1);
                return Promise.reject(reason);
            });
        }
        return promise;
    };
    Peer.prototype.sendNotification = function (method, params) {
        this.assertNotEnded();
        this.push(jrpc.notification(method, params));
    };
    Peer.prototype.pushError = function (error) {
        this.assertNotEnded();
        this.push(jrpc.error(error));
    };
    Peer.prototype._read = function () {
    };
    Peer.prototype._write = function (chunk, encoding, callback) {
        if (chunk instanceof ParseError) {
            this.emit('protocolError', chunk);
            this.pushError(chunk.toErrorObject());
            callback();
            return;
        }
        var message;
        try {
            message = jrpc.parse(chunk);
        }
        catch (e) {
            var error = new InvalidRequest('Not a valid JSON-RPC object', chunk);
            this.emit('protocolError', error);
            this.pushError(error.toErrorObject());
            callback();
            return;
        }
        try {
            switch (message.kind) {
                case 'request':
                    this.handleRequest(message);
                    break;
                case 'notification':
                    this.handleNotification(message);
                    break;
                case 'response':
                    this.handleResponse(message);
                    break;
                case 'error':
                    this.handleError(message);
                    break;
            }
        }
        catch (e) {
            callback(e);
            return;
        }
        callback();
    };
    Peer.prototype.handleRequest = function (request) {
        var _this = this;
        if (this.onRequest) {
            var promise = void 0;
            try {
                promise = Promise.resolve(this.onRequest.call(undefined, request.method, request.params));
            }
            catch (e) {
                promise = Promise.reject(e);
            }
            promise
                .then(function (value) { return _this.push(jrpc.response(request.id, value)); })
                .catch(function (e) {
                var rethrow = false;
                var error;
                if (e instanceof RPCError) {
                    error = e.toErrorObject();
                }
                else {
                    error = new RPCError('Internal error while processing request')
                        .toErrorObject();
                    rethrow = true;
                }
                error.id = request.id;
                _this.pushError(error);
                if (rethrow) {
                    _this.emit('error', e);
                }
            });
        }
        else {
            this.pushError({
                id: request.id,
                code: ErrorCodes.METHOD_NOT_FOUND,
                message: 'No request handler attached',
            });
        }
    };
    Peer.prototype.handleNotification = function (notification) {
        if (this.onNotification) {
            this.onNotification.call(undefined, notification.method, notification.params);
        }
    };
    Peer.prototype.handleResponse = function (response) {
        var id = response.id, result = response.result;
        var rpcCall = this.pendingRequests.get(id);
        if (rpcCall) {
            this.pendingRequests.delete(id);
            rpcCall.resolve(result);
        }
        else {
            throw new Error("Received response with id '" + id + "', which does not correspond to any outstanding RPC call");
        }
    };
    Peer.prototype.handleError = function (message) {
        var id = message.id, error = message.error;
        var rpcError = new RPCError(error.message, error.code, error.data);
        if (id !== null) {
            var rpcCall = this.pendingRequests.get(id);
            if (rpcCall) {
                this.pendingRequests.delete(id);
                rpcCall.reject(rpcError);
            }
            else {
                throw new Error("Received error with id '" + id + "', which does not correspond to any outstanding RPC call");
            }
        }
        else {
            throw rpcError;
        }
    };
    return Peer;
}(stream.Duplex));
export { Peer };
