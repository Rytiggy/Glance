"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const util_1 = tslib_1.__importDefault(require("util"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fdb_protocol_1 = require("@fitbit/fdb-protocol");
const consoleColors = {
    warn: chalk_1.default.keyword('orange'),
    error: chalk_1.default.red,
    exception: chalk_1.default.red,
    assert: chalk_1.default.red,
};
const maxComponentNameLength = Math.max(...Object.values(fdb_protocol_1.FDBTypes.Component).map((componentType) => componentType.length));
function isConsoleTrace(message) {
    return message.stack !== undefined;
}
function createPrefixedLog(message) {
    const component = lodash_1.default.padStart(lodash_1.default.upperFirst(message.emittedBy.component), maxComponentNameLength);
    const timestamp = message.timestamp ? `[${message.timestamp.toLocaleTimeString()}] ` : '';
    const formattedMessage = util_1.default.format(...message.message);
    return `${timestamp}${component}: ${formattedMessage}`;
}
exports.createPrefixedLog = createPrefixedLog;
function addSourcePadding(log, sourcePosition) {
    const terminalWidth = process.stdout.columns || 0;
    const lastLogLine = log.split(/\r?\n/).slice(-1)[0] || '';
    const messageLength = lastLogLine.length + sourcePosition.length;
    let padding;
    if (messageLength > terminalWidth) {
        padding = terminalWidth - ((messageLength % terminalWidth) || 0);
    }
    else {
        padding = terminalWidth - messageLength;
    }
    padding += sourcePosition.length;
    return `${log}${sourcePosition.padStart(padding)}`;
}
exports.addSourcePadding = addSourcePadding;
function formatConsoleMessage(cli, message) {
    const colorizer = consoleColors[message.kind] || chalk_1.default;
    let sourcePosition = '';
    let log = createPrefixedLog(message);
    if (message.position) {
        const position = message.position;
        sourcePosition = `(${position.source}:${position.line + 1},${position.column + 1})`;
        log = addSourcePadding(log, sourcePosition);
    }
    cli.log(colorizer(log));
}
function formatConsoleTrace(cli, message) {
    const frameIndent = '\n  ';
    const colorizer = consoleColors[message.kind] || chalk_1.default;
    const log = createPrefixedLog(message);
    const stackMessage = message.stack
        .map((frame) => {
        return `${frame.name || '?'} at ${frame.source}:${frame.line + 1},${frame.column + 1}`;
    }).join(frameIndent);
    cli.log(colorizer(`${log}${frameIndent}${stackMessage}`));
}
function formatMessage(cli, message) {
    if (isConsoleTrace(message))
        return formatConsoleTrace(cli, message);
    formatConsoleMessage(cli, message);
}
exports.formatMessage = formatMessage;
//# sourceMappingURL=formatMessage.js.map