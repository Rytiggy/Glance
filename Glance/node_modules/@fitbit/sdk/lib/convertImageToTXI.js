"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const image_codec_txi_1 = require("@fitbit/image-codec-txi");
exports.TXIOutputFormat = image_codec_txi_1.TXIOutputFormat;
const plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
const pngjs_1 = require("@fitbit/pngjs");
const PLUGIN_NAME = 'convertImageToTXI';
function pickOutputFormat(image, rgbaOutputFormat = image_codec_txi_1.TXIOutputFormat.RGBA8888) {
    if (!image.color)
        return image_codec_txi_1.TXIOutputFormat.A8;
    if (!image.alpha)
        return image_codec_txi_1.TXIOutputFormat.RGB565;
    return rgbaOutputFormat;
}
function transformPNG(png, rgbaOutputFormat) {
    return new Promise((resolve, reject) => {
        png.on('metadata', (metadata) => {
            png.on('parsed', () => {
                try {
                    const txi = image_codec_txi_1.encode({
                        data: new Uint8ClampedArray(png.data),
                        width: png.width,
                        height: png.height,
                    }, {
                        outputFormat: pickOutputFormat(metadata, rgbaOutputFormat),
                        rle: 'auto',
                    });
                    resolve(Buffer.from(txi));
                }
                catch (e) {
                    reject(e);
                }
            });
        });
        png.on('error', reject);
    });
}
function transformPNGBuffer(file, rgbaOutputFormat) {
    const png = new pngjs_1.PNG();
    const transformer = transformPNG(png, rgbaOutputFormat);
    png.parse(file);
    return transformer;
}
function transformPNGStream(file, rgbaOutputFormat) {
    let started = false;
    return new stream_1.Readable({
        read() {
            if (started)
                return;
            started = true;
            const png = new pngjs_1.PNG();
            transformPNG(png, rgbaOutputFormat)
                .then((txi) => {
                this.push(txi);
                this.push(null);
            })
                .catch((error) => this.emit('error', error));
            file.on('error', (err) => this.emit('error', err)).pipe(png);
        },
    });
}
function convertImageToTXI(options = {}) {
    return new stream_1.Transform({
        objectMode: true,
        transform(file, _, cb) {
            if (file.isNull() || file.extname !== '.png') {
                return cb(undefined, file);
            }
            const fileName = file.relative;
            file.basename += '.txi';
            if (file.isBuffer()) {
                transformPNGBuffer(file.contents, options.rgbaOutputFormat)
                    .then((txi) => {
                    file.contents = txi;
                    cb(undefined, file);
                })
                    .catch((err) => cb(new plugin_error_1.default(PLUGIN_NAME, err, { fileName })));
            }
            else if (file.isStream()) {
                file.contents = transformPNGStream(file.contents, options.rgbaOutputFormat).on('error', (err) => this.emit('error', new plugin_error_1.default(PLUGIN_NAME, err, { fileName })));
                cb(undefined, file);
            }
        },
    });
}
exports.default = convertImageToTXI;
