"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const rollup_pluginutils_1 = require("rollup-pluginutils");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const LanguageServiceHost_1 = tslib_1.__importDefault(require("./LanguageServiceHost"));
const pathUtils_1 = require("../../pathUtils");
const parse_tsconfig_1 = require("./parse-tsconfig");
const tslib_const_1 = tslib_1.__importDefault(require("./tslib.const"));
const formatTSDiagMessage = (tsDiagnostic) => `TS${tsDiagnostic.code}: ${tsDiagnostic.messageText}`;
const generateMessage = (tsDiagnostic) => {
    if (typeof tsDiagnostic.messageText === 'string') {
        return formatTSDiagMessage({
            code: tsDiagnostic.code,
            messageText: tsDiagnostic.messageText,
        });
    }
    const messages = [];
    for (let tsChain = tsDiagnostic.messageText; tsChain.next; tsChain = tsChain.next) {
        messages.push({
            messageText: formatTSDiagMessage(tsChain),
            category: tsChain.category,
        });
    }
    return messages;
};
function typescript(options) {
    const pluginOptions = Object.assign({ include: /\.[tj]sx?$/, exclude: [/\.d\.ts$/, /\/node_modules\//], tsconfig: undefined, tsconfigOverride: undefined, onDiagnostic: () => { } }, options);
    let filter;
    let parsedConfig;
    let service;
    function emitDiagnostics(diagnostics) {
        for (const tsDiagnostic of diagnostics) {
            const diagnostic = {
                category: tsDiagnostic.category,
                messageText: generateMessage(tsDiagnostic),
            };
            if (tsDiagnostic.file) {
                diagnostic.file = {
                    path: tsDiagnostic.file.fileName,
                };
                if (tsDiagnostic.start !== undefined &&
                    tsDiagnostic.length !== undefined) {
                    diagnostic.file.position = {
                        start: tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start),
                        end: tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start + tsDiagnostic.length),
                    };
                }
            }
            pluginOptions.onDiagnostic(diagnostic);
        }
    }
    return {
        name: 'rollup-typescript',
        options() {
            parsedConfig = parse_tsconfig_1.parseTsConfig(pluginOptions.tsconfig, pluginOptions.tsconfigOverride, emitDiagnostics);
            filter = rollup_pluginutils_1.createFilter(pluginOptions.include, pluginOptions.exclude);
            service = typescript_1.default.createLanguageService(new LanguageServiceHost_1.default(parsedConfig), typescript_1.default.createDocumentRegistry());
            emitDiagnostics(service.getCompilerOptionsDiagnostics());
        },
        resolveId(importee, importer) {
            if (importee === 'tslib')
                return tslib_const_1.default.sentinel;
            if (!importer)
                return null;
            const result = typescript_1.default.nodeModuleNameResolver(importee, pathUtils_1.normalizeToPOSIX(importer), parsedConfig.options, typescript_1.default.sys);
            if (result.resolvedModule && result.resolvedModule.resolvedFileName) {
                if (result.resolvedModule.resolvedFileName.endsWith('.d.ts')) {
                    return null;
                }
                return result.resolvedModule.resolvedFileName;
            }
            return null;
        },
        load(id) {
            if (id === tslib_const_1.default.sentinel)
                return tslib_const_1.default.source;
            return undefined;
        },
        transform(code, id) {
            if (!filter(id))
                return undefined;
            const output = service.getEmitOutput(id);
            emitDiagnostics(service.getSyntacticDiagnostics(id));
            emitDiagnostics(service.getSemanticDiagnostics(id));
            if (output.emitSkipped)
                this.error(`Failed to compile ${id}`);
            return {
                code: output.outputFiles.filter((e) => e.name.endsWith('.js'))[0].text,
                map: output.outputFiles.filter((e) => e.name.endsWith('.map'))[0].text,
            };
        },
    };
}
exports.default = typescript;
